package org.gosh.validation.webcash;

import static org.apache.commons.lang.StringUtils.contains;
import static org.apache.commons.lang.StringUtils.isNotEmpty;
import static org.apache.commons.lang.StringUtils.remove;
import static org.apache.commons.lang.StringUtils.split;
import static org.apache.commons.lang.StringUtils.startsWith;

import java.io.IOException;
import java.math.BigDecimal;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.xml.bind.JAXBException;
import javax.xml.datatype.DatatypeConfigurationException;
import javax.xml.datatype.DatatypeFactory;
import javax.xml.datatype.XMLGregorianCalendar;

import org.apache.commons.lang.StringUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.gosh.re.dmcash.bindings.Address;
import org.gosh.re.dmcash.bindings.GOSHCC;
import org.gosh.re.dmcash.bindings.GiftAttributes;
import org.gosh.re.dmcash.bindings.GiftSubtype;
import org.gosh.re.dmcash.bindings.GOSHCC.DonorCplxType;
import org.gosh.re.dmcash.bindings.GOSHCC.Relationship;
import org.gosh.re.dmcash.bindings.GOSHCC.DonorCplxType.Attributes;
import org.gosh.re.dmcash.bindings.GOSHCC.DonorCplxType.ConsCodes;
import org.gosh.re.dmcash.bindings.GOSHCC.DonorCplxType.ConstituentAppeal;
import org.gosh.re.dmcash.bindings.GOSHCC.DonorCplxType.TaxDeclaration;
import org.gosh.re.dmcash.bindings.GOSHCC.DonorCplxType.Attributes.SolicitCodes;
import org.gosh.re.dmcash.bindings.GOSHCC.DonorCplxType.Attributes.Source;
import org.gosh.re.dmcash.bindings.GOSHCC.DonorCplxType.DonationDetails.CashDonationCplxType;
import org.gosh.validation.convertion.AbstractCsvConverter;
import org.gosh.validation.general.error.ErrorReporter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Required;
import org.springframework.integration.annotation.Aggregator;
import org.springframework.integration.annotation.CompletionStrategy;
import org.springframework.integration.core.Message;
import org.springframework.integration.file.FileHeaders;

import com.sun.org.apache.xerces.internal.jaxp.datatype.XMLGregorianCalendarImpl;

/**
 * Takes the two files generated by the web site and aggregates them
 * into one XML file so that further processing can be completed in 
 * a standard way. The two web site files contain donor information 
 * and donation information respectively. 
 * 
 * This also implements a completion strategy so that Spring 
 * Integration knows when it has both files and can run the aggregation.
 */
public class WebDonationsAggregator extends AbstractCsvConverter{
	private Log log = LogFactory.getFactory().getInstance(this.getClass());
	public static final String DONATIONS_HEADER = "\"GiftKey\"	\"DonationKey\"	\"DonorKey\"	\"Amount\"	\"PaidFlag\"	\"GiftAidFlag\"	\"Date\"	\"Reason\"	\"Sub reason\"	\"In memory - title\"	\"memory_forename\"	\"In memory - surname\"	\"In memory - relationship\"	\"Donate description\"	\"Referring site where knowm\"";
	public static final String DONORS_HEADER = "\"Keyfield\"	\"Email\"	\"Title\"	\"Title2\"	\"Forename\"	\"Surname\"	\"Add1\"	\"Add2\"	\"Add3\"	\"Add4\"	\"Add5\"	\"City\"	\"County\"	\"PostCode\"	\"Country\"	\"Country-Other\"	\"Tel\"	\"Comments\"	\"DataProtectFlag\"	\"Date\"";
	
	private LegacyDatabaseLookup legacyDao;
	private ErrorReporter reporter;
	
	@Aggregator
	public Message<String> aggregate(List<String> files) throws IOException, JAXBException, DatatypeConfigurationException {
		log.info("creating web cash file");
		List<String> donorLines = findDonorLines(files);
		int iDonor = donorLines.size() - 1;
		log.info("web cash file has " + iDonor + " donor lines");
		List<String> donationLines = findDonationLines(files); 
		int iDntn = donationLines.size() - 1;
		log.info("web cash file has " + iDntn + " donor lines");
		
		GOSHCC goshcc = setUpGoshcc();
		
		ArrayList<String> errors = new ArrayList<String>();
		Map<String, DonorCplxType> keyFieldToDonor = loadDonors(donorLines, goshcc, errors);
		loadDonations(donationLines, keyFieldToDonor, errors);
		goshcc = loadRelations(donationLines, keyFieldToDonor, goshcc);
		
		Map<String, Object> headers = new HashMap<String, Object>();
		String nowFile = new SimpleDateFormat("yyyyMMddHHmmss").format(new Date());
		headers.put(FileHeaders.FILENAME, "webdonations-" + nowFile + ".xml");
		
		return reporter.log(marshall(goshcc, headers), errors);
	}

	private GOSHCC joiner(GOSHCC goshccRelations, GOSHCC goshcc) {
		if (goshccRelations.getDonorCplxType().isEmpty()){
			log.error("application couldn't add relationships to file or there were no relationship in the original donations file");
			return goshcc;
		}
		goshccRelations.setBatchNo(goshcc.getBatchNo());
		goshccRelations.setSupplierID(goshcc.getSupplierID());	
		for (DonorCplxType donor : goshcc.getDonorCplxType()) {
			goshccRelations.getDonorCplxType().add(donor);
		}
		log.info("Web Cash file has " + goshccRelations.getDonorCplxType().size() + " donor and " + goshccRelations.getRelationship() + " relationships");
		return goshccRelations;
	}

	private List<String> findDonationLines(List<String> files) {
		if (startsWith(files.get(0), DONORS_HEADER)){
			return Arrays.asList(split(files.get(1), "\n"));
		} else {
			return Arrays.asList(split(files.get(0), "\n"));
		}
	}

	private List<String> findDonorLines(List<String> files) {
		if (startsWith(files.get(0), DONORS_HEADER)){
			return Arrays.asList(split(files.get(0), "\n"));
		} else {
			return Arrays.asList(split(files.get(1), "\n"));
		}
	}

	private Map<String, DonorCplxType> loadDonors(List<String> donorLines, GOSHCC goshcc, ArrayList<String> errors) throws DatatypeConfigurationException {
		Map<String, DonorCplxType> keyField2Donor = new HashMap<String, DonorCplxType>();
		for (String donorLine : donorLines) {
			if (isHeader(donorLine)){
				continue;
			}
			
			DonorCplxType donor = new GOSHCC.DonorCplxType();
			String[] fields = getFields(donorLine, "\"\t\"");
			if (fields.length != 20){
				errors.add("The following line did not have the correct number of fields: " + donorLine + ". We seperated out the following: " + Arrays.asList(fields));
				continue;
			}
			
			donor.setSupplierDonorID(fields[0]);
			donor.setTitle1(StringUtils.stripToEmpty(fields[2]));
			donor.setFirstName(fields[4]);
			donor.setLastName(fields[5]);
			
			donor.setChangeOfName(false);
			donor.setPrimaryAddress(false);
			
			ArrayList<String> addressLines = new ArrayList<String>();
			addressLines.add(StringUtils.strip(fields[6], "(!)*#"));
			addressLines.add(StringUtils.strip(fields[7], "(!)*#"));
			addressLines.add(StringUtils.strip(fields[8], "(!)*#"));
			addressLines.add(StringUtils.strip(fields[9], "(!)*#"));
			addressLines.add(StringUtils.strip(fields[10], "(!)*#"));
			donor.setAddress(new Address());
			donor.getAddress().getAddressLine().addAll(addressLines);
			
			donor.setCity(fields[11]);
			donor.setCounty(fields[12]);
			donor.setPostCode(StringUtils.strip(fields[13], "(!)*#"));
			donor.setCountry(fields[14]);
			donor.setCity(StringUtils.strip(fields[11], "(!)-*#"));
			donor.setCounty(StringUtils.strip(fields[12], "(!)-*#"));
			donor.setPostCode(StringUtils.strip(fields[13], "(!)*#"));
			donor.setCountry(StringUtils.strip(fields[14], "(!)-*#"));
			
			addConstituentCodeWithDate(donor, fields);
			
			addPhoneEmail(donor, fields[1], "Email");
			addPhoneEmail(donor, fields[16], "Home");
			
			Attributes attributes = new GOSHCC.DonorCplxType.Attributes();
			donor.setAttributes(attributes);
			
			donor.setGender("Unknown");
			
			Source source = new Source();
			attributes.setSource(source);
			source.setCategory("Source");
			source.setDescription("Online");
			source.setDate(donor.getConsCodes().get(0).getDateFrom());
			source.setComment("Obtained via Netbanx");
			
			if ("Y".equals(fields[18])){
				SolicitCodes solicitCodes = new SolicitCodes();
				attributes.getSolicitCodes().add(solicitCodes);
				solicitCodes.setCategory("Solicit Codes");
				solicitCodes.setDescription("3rd Party Data Protection Opt Out");
				solicitCodes.setDate(donor.getConsCodes().get(0).getDateFrom());
				solicitCodes.setComment("Obtained via Netbanx");
			}
			if ("Y".equals(fields[16])){
				addDataProtectionAttribute(donor);
			}

			goshcc.getDonorCplxType().add(donor);
			keyField2Donor.put(fields[0], donor);	
		}
		return keyField2Donor;
	}

	private void loadDonations(List<String> donationLines, Map<String, DonorCplxType> keyField2Donor, List<String> lookupErrors) throws DatatypeConfigurationException {
		for (String donationLine : donationLines) {
			if (isHeader(donationLine)|| isEmptyLine(donationLine)){
				continue;
			}

			String[] fields = getFields(donationLine, "\"\t\"");

			DonorCplxType donor = keyField2Donor.get(fields[2]);
			if (donor == null){
				log.info("donor was null for donation line with donor key: " + fields[2]);
				continue;			
			}

			GOSHCC.DonorCplxType.DonationDetails donationDetails = new GOSHCC.DonorCplxType.DonationDetails();
			donor.setDonationDetails(donationDetails);
			List<CashDonationCplxType> cashDonationCplxType = donationDetails.getCashDonationCplxType();

			CashDonationCplxType donation = new GOSHCC.DonorCplxType.DonationDetails.CashDonationCplxType();

			donation.setType("Cash");
			donation.setSubType(GiftSubtype.DONATIONS_INTERNET_1014);
			donation.setPaymentType("Credit Card");
			donation.setCardType("Unknown");
			donation.setReference("webdata" + new SimpleDateFormat("dd.MM.yyyy").format(new Date()));
			donation.setPostStatus("Not Posted");
			donation.setLetterCode("01");
			donation.setAmount(new BigDecimal(fields[3]));			
			donation.setDate(toDate(fields[6], "yyyy-MM-dd HH:mm:ss", donor.getConsCodes().get(0).getDateFrom()));
			donation.setAmount(new BigDecimal(fields[3]));
			donation.setDate(toDateWithSlash(fields[6], donor.getConsCodes().get(0).getDateFrom()));
			// This is to enable reprocessing
			donation.setDonateDescription(cleanComment(fields[13]));

			String donateDescription = cleanComment(fields[13]);
			donation.setDonateDescription(donateDescription);
			// Gift Notes Issue Fix: Create a Gift Attribute with donate description
			if (StringUtils.isNotBlank(donateDescription)){
				GiftAttributes gatt = new GiftAttributes();
				gatt.setCategory("Internet Donation Notes");
				String donateDescription60 = StringUtils.abbreviate(donateDescription, 60);
				gatt.setDescription(donateDescription60);
				gatt.setDate(donation.getDate());
				if (donateDescription.length()>60){
					gatt.setComment(StringUtils.substring(donateDescription, 57));
				} else {
					gatt.setComment("");
				}
				donation.getGiftAttributes().add(gatt);
			}
			
			
			cashDonationCplxType.add(donation);
			
			if ("1".equals(fields[5])){
				TaxDeclaration declaration = new GOSHCC.DonorCplxType.TaxDeclaration();
				declaration.setDeclarationDate(donation.getDate());
				declaration.setDeclarationIndicator("Oral"); // check this
				declaration.setStartDate(minusSixFiscalYears(donation.getDate()));
				declaration.setTaxPayer(true);
				declaration.setConfirmationDate(donation.getDate());
				donor.setTaxDeclaration(declaration);
			}
			
			String contact = legacyDao.lookupCampaignAppealFundConstituentCodesAndContact(fields[7], fields[8], donation, donor);

			ConstituentAppeal constituentAppeal = new ConstituentAppeal();
			constituentAppeal.setAppealID(donation.getAppeal());
			constituentAppeal.setPackageID(donation.getPackage() == null ? "" : donation.getPackage());
			constituentAppeal.setResponse("Responded");
			XMLGregorianCalendar now = DatatypeFactory.newInstance().newXMLGregorianCalendar(new GregorianCalendar());
			constituentAppeal.setDate(now);
//			constituentAppeal.setMarketingSourceCode(donor.getSupplierDonorID());
			donor.setConstituentAppeal(constituentAppeal);

			// bit of a hack
			if (!"1".equals(fields[4])){ // if the gift has not been paid
				donor.setDonationDetails(null);
			} else {
				addDirectMarketingType(donor, "Individual Donor");
				if (contact == null){
					lookupErrors.add("["+donor.getFirstName()+ " "+ donor.getLastName() + " of " +donor.getPostCode()+ "]: We couldn't lookup the reason/subreason combination of " + fields[7] + "/" + fields[8]);
				}

			}
		}
	}

	private boolean isEmptyLine(String donationLine) {
		String line = remove(donationLine,"﻿");
		line = remove(donationLine,",");
		
		return StringUtils.isBlank(line);
	}

	private String cleanComment(String field) {
		field = StringUtils.strip(field, "!*#");
		if (StringUtils.containsIgnoreCase(field, "N/A")){
			field = StringUtils.remove(field, "N/A");
		}
		return field;
	}

	private GOSHCC loadRelations(List<String> donationLines, Map<String, DonorCplxType> keyField2Donor, GOSHCC goshcc) throws DatatypeConfigurationException {
		GOSHCC goshccRelations = new GOSHCC();
		
		long id = new Date().getTime();
		
		for (String donationLine : donationLines) {
			if (isHeader(donationLine)){
				continue;
			}
			
			String[] fields = getFields(donationLine, "\"\t\"");
			
			DonorCplxType donor = keyField2Donor.get(fields[2]);
			if (donor == null){
				log.info("donor was null for donation line with donor key: " + fields[2]);
				continue;			
			}
			
			// Also try to fill out empty fields in Relations model according to business rules
			if (isNotEmpty(fields[10]) && isNotEmpty(fields[11])){
				DonorCplxType relation = new DonorCplxType();
				relation.setTitle1(fields[9]);
				relation.setFirstName(fields[10]);
				relation.setLastName(fields[11]);		
				relation.setGender("Unknown");
				
				ConsCodes cffConsCode = new ConsCodes();
				cffConsCode.setCode("CFF");
				
				Calendar calendar = new GregorianCalendar();
				int year = calendar.get(Calendar.YEAR);
				int month = calendar.get(Calendar.MONTH);
				int day = calendar.get(Calendar.DAY_OF_MONTH);
				
				XMLGregorianCalendar now = DatatypeFactory.newInstance().newXMLGregorianCalendar(year, month, day, 0, 0, 0, 0, 0);
				
				cffConsCode.setDateFrom(now);
				relation.getConsCodes().add(cffConsCode);
				
				ConsCodes memoConsCode = new ConsCodes();
				memoConsCode.setCode("MEMO");
				memoConsCode.setDateFrom(now);
				relation.getConsCodes().add(memoConsCode);
				
				relation.setDeceasedDate(now);
				
				goshccRelations.getDonorCplxType().add(relation);
				
				Relationship relationship = new Relationship();
				relationship.setSupplierDonorID(donor.getSupplierDonorID());
				String generatedSupplierDonorId = String.valueOf(++id);
				relation.setSupplierDonorID(generatedSupplierDonorId);
				relationship.setRelatedSupplierDonorID(String.valueOf(id));
				relationship.setRelationshipDescriptor(fields[12]);
				relationship.setReciprocate(true);
				goshccRelations.getRelationship().add(relationship);
					
				// Should we leave this out of the relation or should we change the gral schema?
				Attributes attributes = new GOSHCC.DonorCplxType.Attributes();
				relation.setAttributes(attributes);
				Source source = donor.getAttributes().getSource();
				attributes.setSource(source);
				
				ConstituentAppeal constitAppeal = new ConstituentAppeal();
				constitAppeal.setAppealID(donor.getConstituentAppeal().getAppealID());
				constitAppeal.setPackageID(donor.getConstituentAppeal().getPackageID()!= null ? donor.getConstituentAppeal().getPackageID() : "");
				constitAppeal.setResponse("Responded");
				constitAppeal.setDate(donor.getConstituentAppeal().getDate());
				relation.setConstituentAppeal(constitAppeal);
			} 
		}
		
			return copyRightMarketingSourceCodeForAllDonors(joiner(goshccRelations, goshcc));
	}

	private GOSHCC.DonorCplxType.ConsCodes addConstituentCodeWithDate(DonorCplxType donor, String[] fields) {
		GOSHCC.DonorCplxType.ConsCodes consCodes = new GOSHCC.DonorCplxType.ConsCodes();
		consCodes.setCode("GEN");
		consCodes.setDateFrom(toDate(fields[19], "yyyy-MM-dd HH:mm:ss", new XMLGregorianCalendarImpl()));
		donor.getConsCodes().add(consCodes);
		return consCodes;
	}
	
	private boolean isHeader(String line) {
		line = remove(line,"﻿");
		return contains(line, DONATIONS_HEADER) || contains(line, DONORS_HEADER);
	}
	
	private void addDataProtectionAttribute(DonorCplxType donor) {
		List<SolicitCodes> solicitCodes = donor.getAttributes().getSolicitCodes();
		SolicitCodes solicitCode = new SolicitCodes();
		solicitCode.setDescription("Data Protection Opt Out");
		solicitCode.setCategory("Solicit Codes");
		solicitCode.setDate(donor.getConsCodes().get(0).getDateFrom());
		solicitCode.setComment("Obtained via Netbanx");
		solicitCodes.add(solicitCode);
	}
	
	private GOSHCC copyRightMarketingSourceCodeForAllDonors(GOSHCC goshcc) {
		for (DonorCplxType donor2 : goshcc.getDonorCplxType()){
			if (donor2.getConstituentAppeal() != null){
				if (StringUtils.isNotBlank(donor2.getSupplierDonorID())){
					donor2.getConstituentAppeal().setMarketingSourceCode(donor2.getSupplierDonorID());
				}
			} else {
				log.info(donor2.getFirstName() + " " + donor2.getLastName() + " supplierDonorID: " +donor2.getSupplierDonorID()+ " has null Constituent Appeal");
			//log.info(donor2.getFirstName() + " " + donor2.getLastName() + " supplierDonorID: " +donor2.getSupplierDonorID()+ " marketing source code: " + constitAppeal.getMarketingSourceCode());
			}
		}
		return goshcc;
	}
	
	@CompletionStrategy
	public boolean checkCompleteness(List<String> fileList) throws IOException {
		if (fileList==null||fileList.size()!=2){
			return false;			
		}
		
		List<String> firstFileLines = Arrays.asList(split(fileList.get(0), "\n"));
		List<String> secondFileLines = Arrays.asList(split(fileList.get(1), "\n"));
		
		return (equalsIgnoreWhitespace(DONORS_HEADER, firstFileLines.get(0)) && equalsIgnoreWhitespace(DONATIONS_HEADER,secondFileLines.get(0)))
			|| (equalsIgnoreWhitespace(DONORS_HEADER, secondFileLines.get(0)) && equalsIgnoreWhitespace(DONATIONS_HEADER,firstFileLines.get(0)));
	}
	
	@Required
	public void setLegacyDao(LegacyDatabaseLookup legacyDao) {
		this.legacyDao = legacyDao;
	}
	
	@Required @Autowired
	public void setReporter(ErrorReporter reporter) {
		this.reporter = reporter;
	}
}

